<?php

declare(strict_types=1);
/**
 * @copyright Copyright &copy; bbr.de, 2016 - 2017
 * @version 1.0.0
 * @author Günter Pöhl <guenter-poehl@hausverwaltung-poehl.de>
 * @link http://www.bbr.com/
 * @license http://www.bbr.de/license/
 */

namespace gpoehl\phpReport;

use NumberFormatter;

/**
 * Prototype provides some basic output to help developing classes using backbone.
 * All methods may be called as prototye methods instead of owner methods.
 */
class Prototype {

    private $bb;            // The backbone object. 
    private $nfo;
    private $table = <<<'TABLE1'
        <table border="0"><tr>
            <th style="background-color: %1$s; width: %2$dpx; text-align: center">%3$s</th>  
            <th style="background-color: %1$s; width: 120px;">%4$s</th>
            <th style="width: %5$dpx"></th>
            <th style="text-align: left">%6$s</th>
        </tr>
        <tr><td colspan="3"></td><td>%7$s<td></tr>
        </table>
TABLE1;
    private $contentTable = <<<'TABLE2'
          <table border="0"><tr><td style="vertical-align: top; width: 150px"><strong>%1$s </strong></td><td>%2$s</td></tr></table>     
    TABLE2;
    private $colors = [
        'init' => '#ccff33',
        'close' => '#ccff33',
        'totalHeader' => '#b4faa3',
        'totalFooter' => '#b4faa3',
        'groupHeader' => '#93db00',
        'groupFooter' => '#93db00',
        'detail' => '#ffb76f',
        'noData' => '#ff4000',
        'noData_n' => '#f78181',
    ];
    private $signs = [
        'groupHeader' => '&gt;',
        'groupFooter' => '&lt;',
        'detail' => '&#9826;',
        'noData' => '&#9826;',
        'noData_n' => '&#9826;',
    ];

    /**
     * Build a html table with data related to a method
     * Header line has a sign, method name and level with a fixed width.
     * Then the group name and optional headerData follows in column 4.
     * Lines after header line are empty in the first 3 colums. $content
     * is printed at column 4.
     * @param string $content Data prepared in methods
     * @param string $headerData Additional data to be printed in method header line.
     * @return string Html table with all data for a method
     */
    private function renderAction(string $content, string $headerData = ''): string {
        $methodKey = $this->bb->method[1];
        $headerCol3 = $this->getMethodName() . $headerData;
        $sign = ($this->signs[$methodKey]) ?? '';
        $color = $this->colors[$methodKey];
        // Modify groupheader and footer background colors
        if (substr($methodKey, 0, 5) === 'group') {
            $color = dechex(hexdec($color) + (hexdec("000030") * $this->bb->getLevel()));
        }
        // width of column 1
        $width = ($this->bb->getLevel() > 0) ? $this->bb->getLevel() * 16 + 10 : 0;
        // width of column 3 (constant is sum of column 1 and column 3
        $widthCol3 = 100 - $width;

        if (!in_array($methodKey, ['init', 'close', 'noData'])) {
            $methodKey .= '&nbsp;' . $this->bb->getLevel();
        }
        return "\n" . sprintf($this->table, $color, $width, $sign, $methodKey, $widthCol3, $headerCol3, $content);
    }

    /**
     * @param report $report The report object
     */
    public function __construct(report $report) {
        $this->bb = $report;
        $this->nfo = new NumberFormatter('EN_US', NumberFormatter::ORDINAL);
    }

    /**
     * Call related method to the one last called in target class.
     * Parameter are collected here. This reduces the logic in report class. 
     * @return string Output generated by methods to be called
     */
    public function magic(): string {
        $method = $this->bb->method[1];
        switch ($method) {
            case 'groupHeader':
            case 'groupFooter':
                $group = $this->bb->groups->groups[$this->bb->getLevel()];
                return $this->$method(
                                $this->bb->groups->values[$this->level],
                                $this->bb->getRow($group->dim), // row value
                                $this->bb->getRowKey($group->dim)       // row key 
                );
            case 'detail':
                return $this->$method($this->bb->getRow(), $this->bb->getRowKey());
            case 'noData_n':
                return $this->$method($this->bb->currentDimID);
            default:
                return $this->$method();
        }
    }

    /**
     * Get the name of method which would have been called in target class
     * 
     * @return string When action is a string or a closure the related constant
     * is returned.
     */
    private function getMethodName(): string {
        $method = $this->bb->method;
        // subtract 10 when type has increased in backbone getCallable 
        if ($method[0] >= 10) {
            $method[0] -= 10;
        }
        if ($method[0] === Report::METHOD) {
            return $method[3];
        }
        // Build method name from class and method
        if ($method[0] === Report::CALLABLE) {
            $name = '';
            is_callable($method[3], true, $name);
            return $name;
        }
        return ['string', 'closure'][$method[0]];
    }

    public function init() {
        return $this->renderAction('Place here all stuff to initialize the job.');
    }

    public function close() {
        return $this->renderAction('Cleanup your dishes here.');
    }

    public function totalHeader() {
        return $this->renderAction('A good place to print selection criteria or a cover page.');
    }

    public function totalFooter() {
        $content = 'A good place to print global summaries.';
        $content .= $this->renderTotals(0);
        $content .= $this->renderRowCounter();
        $content .= $this->renderChildGroupCounter();
        return $this->renderAction($content);
    }

    public function groupHeader($val, $row, $rowKey, $dimID) {
        $content = $this->renderRowValues($row, $rowKey);
        $content .= $this->renderGroupCounter();
        return $this->renderAction($content, ", Dim = $dimID, Group value = $val");
    }

    /**
     * Prepare output for group footers
     * Note that $this->bb->dims->current has the dim which forced the group change.
     * The related dim to a group must be get out of the group object.
     * @param type $val
     * @param type $row
     * @param type $rowKey
     * @return string Table with data related to a group footer
     */
    public function groupFooter($val, $row, $rowKey, $dimID) {
        $content = ($this->bb->isLast()) ?
                "I'm the last " . $this->bb->getGroupName() :
                "There are more {$this->bb->getGroupName()}(s)";
        $content .= ($this->bb->getLevel() === 1) ? ' within this job.' :
                ' in group ' . $this->bb->getGroupName($this->bb->getLevel() - 1);
        $content .= '<br>' . $this->renderRowValues($row, $rowKey);
        $content .= $this->renderTotals($this->bb->getLevel());
        $content .= $this->renderBuckets($this->bb->getLevel());

        $content .= $this->renderRowCounter();
        $content .= $this->renderGroupCounter();
        $content .= $this->renderChildGroupCounter();
        $dim = $this->bb->groups->groups[$this->bb->getLevel()]->dim;
        return $this->renderAction($content, ", Dim = $dim, Group value = $val");
    }

    public function detail($row, $rowKey): string {
        $content = $this->renderRowValues($row, $rowKey);
        $content .= $this->renderTotals($this->bb->getLevel() - 1);
        $content .= $this->renderRowCounter();
        return $this->renderAction($content, ", Dim = {$this->bb->currentDimID}");
    }

    public function noData() {
        return $this->renderAction('No data passed to this job.');
    }

    public function noData_n($dim) {
        $val = $this->bb->getGroupValue($this->bb->getLevel() - 1); // row value
        $content = "No data given for group {$this->bb->getGroupName($this->bb->getLevel() - 1)}. Value = $val";
//        $content .= '<br>' . $this->renderRowCounter();
        return $this->renderAction($content, ", Dim = $dim");
    }

    /**
     * Prepare values of $row to be printed in one line
     * @param type $row
     * @param type $rowKey
     * @return string Values within $row 
     */
    private function renderRowValues($row, $rowKey) {
        If (is_object($row)) {
            // make an array from public attributes of object.
            $row = get_object_vars($row);
        }
        // transfer $row to a string and remove trailing substring 'array(' and ending ',)'
        $out = substr(var_export($row, true), 8, -3);
        // Truncate to a maximum length of 250
        if (strlen($out) > 250) {
            $out = substr($out, 0, 245) . ' ...';
        }
        return "\n" . sprintf($this->contentTable, 'Row values:', $out);
    }

    /**
     * Render totals for a given level
     * Totals has names of calculate attributes, sum, nn and nz
     * @param int $level
     * @return string html table of total values
     */
    private function renderTotals(int $level = null): string {
        if (empty ($this->bb->total->items)){
            return "\n" . sprintf($this->contentTable, 'Calculated attributes:', 'Nothing to be summarized.');
        }
        $out = "<table border='1'" . ' style="border-collapse: collapse">'
                . "\n<tr><th>Name</th><th>sum</th><th>nn</th><th>nz</th><th>min</th><th>max</th></tr>";
        foreach ($this->bb->total->items as $name => $attr) {
            $out .= '<tr><td>' . $name . '</td>';
            $out .= '<td>' . $attr->sum($level) . '</td>';
            $out .= '<td>' . $attr->nn($level) . '</td>';
            $out .= '<td>' . $attr->nz($level) . '</td>';
            $out .= '<td>' . $attr->min($level) . '</td>';
            $out .= '<td>' . $attr->max($level) . '</td></tr>';
        }
        return "\n" . sprintf($this->contentTable, 'Calculated attributes:', $out . '</table>');
    }

    /**
     * Render totals for a given level
     * Totals has names of calculate attributes, sum, nn and nz
     * @param int $level
     * @return string html table of total values
     */
    private function renderBuckets(int $level): string {
        if (!isset($this->bb->buckets[$level])) {
            return '';
        }
        foreach (array_keys($this->bb->buckets[$level]) as $calcName) {
            $name[] = $calcName;
            foreach ($calcname as $bucket) {
                $sum[] = $this->bb->sum($calcName, $level);
                $nn[] = $this->bb->nnCount($calcName, $level);
                $nz[] = $this->bb->nzCount($calcName, $level);
            }
        }
        $out = "\n<tr><th>Name</th><th>" . implode('</th><th>', $name) . '</th></tr>';
        $out .= "\n<tr><td>sum</td><td>" . implode('</td><td>', $sum) . '</td></tr>';
        $out .= "\n<tr><td>nn</td><td>" . implode('</td><td>', $nn) . '</td></tr>';
        $out .= "\n<tr><td>nz</td><td>" . implode('</td><td>', $nz) . '</td></tr>';
        $out = "<table border='1'" . ' style="border-collapse: collapse">' . $out . "</table>";
        return "\n" . sprintf($this->contentTable, 'Calculated attributes:', $out);
    }

    /**
     * Render row counter
     * Renders a table for all row counters from level 0 to the actual level
     * @return string html table of row counters
     */
    private function renderRowCounter(): string {
        $maxLevel = end($this->bb->rc->items)->maxLevel;
        $out = '<table border="1" style="border-collapse: collapse"><tr><th>Level</th>';
        for ($i = 0; $i <= $maxLevel; $i++) {
            $out .= "<th>$i</th>";
        }
        $out .= '</tr>';

        foreach ($this->bb->rc->items as $dim => $rc) {
            $out .= "<tr><td>Dim $dim</td>";
            for ($i = 0; $i <= $maxLevel; $i++) {
                if ($i <= $rc->maxLevel) {
                    $out .= '<td>' . $rc->sum($i) . '</td>';
                } else {
                    $out .= '<td></td>';
                }
            }
            $out .= '</tr>';
        }
        return "\n" . sprintf($this->contentTable, 'Row counter:', $out . '</table>');
    }

    /**
     * Render group counter
     * Numbers shown are for the group counter of the current level.
     *  
     * Renders a table for the group counter from the currnet level - 0 up to level 0. 
     * It could also be described as "The current group is the nth occurrece 
     * within a higer group.
     * @return string html table of row counters
     */
    private function renderGroupCounter(): string {
        $level = $this->bb->getLevel();
        $out = "Group $level is ";
        // Walk up from current level - 1 to level = 0  
        for ($i = $level - 1; $i >= 0; $i--) {
            $out .= $this->nfo->format($this->bb->gc->items[$level]->sum($i)) . " time in group $i, ";
        }
        return "\n" . sprintf($this->contentTable, 'Group counter &uarr;:', substr($out, 0, -2) . '.');
    }

    /**
     * Render group counter for child groups
     * Child groups are those on lower level of a given level. They are linked
     * to the count colletor having a key greater than the given level.
     * @return string html table of row counters
     */
    private function renderChildGroupCounter(): string {
        $level = $this->bb->getLevel();
        if ($level >= $this->bb->groups->maxLevel) {
            // till now when further dim is defined but not yet initialized
            $wrk = (empty($this->bb->detailLevel)) ? " till now" : '';
            $out = "Group $level is{$wrk} the lowest group level. So there are no child groups  ";
        } else {
            $out = "Group $level has ";
            $numberOfGroups = $this->bb->groups->maxLevel;
            $wrk = $this->bb->gc->rsum($level + 1, $numberOfGroups, $level, true);
            foreach ($wrk as $key => $sum) {
                $out .= "$sum times group $key, ";
            };
        }
        return "\n" . sprintf($this->contentTable, 'Group counter &darr;:', substr($out, 0, -2) . '.');
    }

}
